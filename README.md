This was made in an effort to better understand the material laid out in [The Semantics of K](https://github.com/kframework/kore/blob/master/docs/semantics-of-k.pdf), particularly chapters 4-8. The underlying components (IE the definition of things like #Sort, #wellFormed, etc) use the definitions given in the Meta K chapter (chapter 7) as opposed to the ones given later in Kore. The 'main.lean' file containins a constructive definition of the example matching logic theory given in chapter 8. The only thing I'm still really shakey on is the behavior of the sort parameters to ceiling and parametric predicates, so don't look at those.
<p/>
Right now, the matching logic terms are reduced by regular old Lean functions that match the specified behaviors rather than ones that more accurately follow matching logic's exact semantics for binding and application. I would like to see the approach defining them as functional constructs mentioned in chapter 4 before taking it on.
In any case, I found this to be extremely helpful in actually figuring out how matching logic/K works; the many-sorted nature of ML combined with the amount of non-trivial coercions/lifts it involves can be pretty confusing without an actual model to see what you're doing.
<p/>
For people more interested in Kore, major differences between K and Kore include:

+ Meta sorts in Kore are either one of the ten constants from K, or sort variables. You can't add parametric sorts willy nilly to Kore as written.
+ In K/matching logic, #Pattern is stated to have only the base constructions laid out at the very beginning of the paper (variable, application, negation, conjunction, exists), and the auxiliary logical connectives (or, equality, iff..) are defined as derived constructs/combinations of the basic constructions. In Kore, there exists a unique production rule for each base constructor as well as derived construct.
+ While chapter 7's definition (p. 31) of meta pattern constructions only mentions/demonstrates construction from components in the meta-theory, Kore's definition of `pattern` constructions allows for object and meta patterns to accept `pattern` terms constructed from either object or meta components in their constructors.
+ Most places where you would use a #Symbol in Meta K (primarily pattern application), you end up using an element of 'head' in Kore, which can eventually be lifted to a Symbol based on rules given in chapter 9.
+ Kore adds modules, hooks, attributes, and aliases, which add bookkeeping but do not significantly change the core logic/constructions.